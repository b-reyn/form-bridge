"""
HMAC Validator - Optimized for ARM64 Lambda Functions
Provides cached HMAC signature validation for multi-tenant authentication
"""

import hmac
import hashlib
import json
import time
from datetime import datetime, timezone
from typing import Dict, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import boto3
from aws_lambda_powertools import Logger

logger = Logger(child=True, service="hmac-validator")


class ValidationStatus(Enum):
    """HMAC validation result status"""
    VALID = "valid"
    INVALID_SIGNATURE = "invalid_signature"
    INVALID_TIMESTAMP = "invalid_timestamp"
    MISSING_HEADERS = "missing_headers"
    TENANT_NOT_FOUND = "tenant_not_found"
    RATE_LIMITED = "rate_limited"
    ERROR = "error"


@dataclass
class ValidationResult:
    """Result of HMAC validation attempt"""
    status: ValidationStatus
    tenant_id: Optional[str] = None
    error_message: Optional[str] = None
    validation_time_ms: int = 0
    from_cache: bool = False


class SecretCache:
    """Thread-safe secret cache optimized for ARM64 Lambda performance"""
    
    def __init__(self, ttl_seconds: int = 300):
        self.cache = {}
        self.ttl = ttl_seconds
    
    def get(self, tenant_id: str) -> Optional[Tuple[str, float]]:
        """Get cached secret with metadata"""
        if tenant_id in self.cache:
            secret, cached_at, version = self.cache[tenant_id]
            if time.time() - cached_at < self.ttl:
                return secret, version
            else:
                # Remove expired entry
                del self.cache[tenant_id]
        return None
    
    def set(self, tenant_id: str, secret: str, version: str = "CURRENT") -> None:
        """Cache secret with version info"""
        self.cache[tenant_id] = (secret, time.time(), version)
    
    def invalidate(self, tenant_id: str = None) -> None:
        """Invalidate cache entry or all entries"""
        if tenant_id:
            self.cache.pop(tenant_id, None)
        else:
            self.cache.clear()
    
    def get_stats(self) -> Dict[str, int]:
        """Get cache statistics"""
        return {
            'entries': len(self.cache),
            'memory_usage_bytes': sum(
                len(secret) + len(tenant_id) + 64  # Approximate overhead
                for tenant_id, (secret, _, _) in self.cache.items()
            )
        }


class HMACValidator:
    """
    High-performance HMAC validator with secret caching
    Optimized for ARM64 Lambda functions with multi-tenant isolation
    """
    
    def __init__(self, 
                 secret_prefix: str,
                 timestamp_tolerance_seconds: int = 300,
                 cache_ttl_seconds: int = 300):
        """
        Initialize HMAC validator
        
        Args:
            secret_prefix: Prefix for tenant secrets in Secrets Manager
            timestamp_tolerance_seconds: Maximum age of timestamps (default 5 minutes)
            cache_ttl_seconds: Secret cache TTL (default 5 minutes)
        """
        self.secret_prefix = secret_prefix
        self.timestamp_tolerance = timestamp_tolerance_seconds
        self.secret_cache = SecretCache(cache_ttl_seconds)
        
        # Initialize Secrets Manager client (reused across invocations)
        self.secrets_client = boto3.client('secretsmanager')
        
        # Performance metrics
        self.cache_hits = 0
        self.cache_misses = 0
        self.validation_count = 0
    
    def validate_request(self, 
                        tenant_id: str,
                        timestamp: str, 
                        signature: str,
                        body: str = '') -> ValidationResult:
        """
        Validate HMAC signature for tenant request
        
        Args:
            tenant_id: Tenant identifier
            timestamp: Request timestamp (ISO format)
            signature: HMAC-SHA256 signature to validate
            body: Request body content
            
        Returns:
            ValidationResult with status and metadata
        """
        start_time = time.time()
        self.validation_count += 1
        
        try:
            # Validate inputs
            if not all([tenant_id, timestamp, signature]):
                return ValidationResult(
                    status=ValidationStatus.MISSING_HEADERS,
                    error_message="Missing required authentication headers"
                )
            
            # Validate timestamp to prevent replay attacks
            if not self._is_timestamp_valid(timestamp):
                return ValidationResult(
                    status=ValidationStatus.INVALID_TIMESTAMP,
                    tenant_id=tenant_id,
                    error_message="Timestamp outside acceptable range"
                )
            
            # Get tenant secret (with caching)
            secret_result = self._get_tenant_secret(tenant_id)
            if not secret_result:
                return ValidationResult(
                    status=ValidationStatus.TENANT_NOT_FOUND,
                    tenant_id=tenant_id,
                    error_message="Tenant secret not found"
                )
            
            secret, from_cache = secret_result
            
            # Validate HMAC signature
            is_valid = self._validate_signature(timestamp, body, signature, secret)
            
            validation_time_ms = int((time.time() - start_time) * 1000)
            
            if is_valid:
                logger.debug("HMAC validation successful", extra={
                    'tenant_id': tenant_id,
                    'from_cache': from_cache,
                    'validation_time_ms': validation_time_ms
                })
                
                return ValidationResult(
                    status=ValidationStatus.VALID,
                    tenant_id=tenant_id,
                    validation_time_ms=validation_time_ms,
                    from_cache=from_cache
                )
            else:
                logger.warning("HMAC validation failed", extra={
                    'tenant_id': tenant_id,
                    'validation_time_ms': validation_time_ms
                })
                
                return ValidationResult(
                    status=ValidationStatus.INVALID_SIGNATURE,
                    tenant_id=tenant_id,
                    error_message="Invalid HMAC signature",
                    validation_time_ms=validation_time_ms,
                    from_cache=from_cache
                )
                
        except Exception as e:
            logger.error("HMAC validation error", extra={
                'tenant_id': tenant_id,
                'error': str(e)
            })
            
            return ValidationResult(
                status=ValidationStatus.ERROR,
                tenant_id=tenant_id,
                error_message=f"Validation error: {str(e)}",
                validation_time_ms=int((time.time() - start_time) * 1000)
            )
    
    def _is_timestamp_valid(self, timestamp: str) -> bool:
        """Validate request timestamp to prevent replay attacks"""
        try:
            # Parse timestamp (supporting both with and without 'Z')
            if timestamp.endswith('Z'):
                req_time = datetime.fromisoformat(timestamp[:-1] + '+00:00')
            else:
                req_time = datetime.fromisoformat(timestamp)
            
            # Ensure timezone aware
            if req_time.tzinfo is None:
                req_time = req_time.replace(tzinfo=timezone.utc)
            
            # Check if within tolerance
            now = datetime.now(timezone.utc)
            age_seconds = abs((now - req_time).total_seconds())
            
            return age_seconds <= self.timestamp_tolerance
            
        except (ValueError, TypeError) as e:
            logger.warning("Invalid timestamp format", extra={
                'timestamp': timestamp,
                'error': str(e)
            })
            return False
    
    def _get_tenant_secret(self, tenant_id: str) -> Optional[Tuple[str, bool]]:
        """
        Get tenant secret with caching support
        
        Returns:
            Tuple of (secret, from_cache) or None if not found
        """
        # Check cache first
        cached_result = self.secret_cache.get(tenant_id)
        if cached_result:
            secret, version = cached_result
            self.cache_hits += 1
            return secret, True
        
        # Fetch from Secrets Manager
        self.cache_misses += 1
        
        try:
            secret_name = f"{self.secret_prefix}/{tenant_id}"
            
            # Try current version first
            response = self.secrets_client.get_secret_value(
                SecretId=secret_name,
                VersionStage='AWSCURRENT'
            )
            
            secret_data = json.loads(response['SecretString'])
            secret = secret_data['shared_secret']
            
            # Cache the secret
            self.secret_cache.set(tenant_id, secret, "CURRENT")
            
            return secret, False
            
        except self.secrets_client.exceptions.ResourceNotFoundException:
            logger.warning("Tenant secret not found", extra={'tenant_id': tenant_id})
            return None
            
        except Exception as e:
            # During rotation, try pending version
            try:
                response = self.secrets_client.get_secret_value(
                    SecretId=secret_name,
                    VersionStage='AWSPENDING'
                )
                
                secret_data = json.loads(response['SecretString'])
                secret = secret_data['shared_secret']
                
                # Cache with pending version flag
                self.secret_cache.set(tenant_id, secret, "PENDING")
                
                logger.info("Using pending secret version during rotation", extra={
                    'tenant_id': tenant_id
                })
                
                return secret, False
                
            except Exception:
                logger.error("Failed to retrieve tenant secret", extra={
                    'tenant_id': tenant_id,
                    'error': str(e)
                })
                return None
    
    def _validate_signature(self, timestamp: str, body: str, 
                          signature: str, secret: str) -> bool:
        """
        Validate HMAC-SHA256 signature using constant-time comparison
        
        Args:
            timestamp: Request timestamp
            body: Request body
            signature: Provided signature
            secret: Tenant secret key
            
        Returns:
            True if signature is valid
        """
        try:
            # Construct message exactly as client should
            message = f"{timestamp}\n{body}"
            
            # Calculate expected signature
            expected_signature = hmac.new(
                secret.encode('utf-8'),
                message.encode('utf-8'),
                hashlib.sha256
            ).hexdigest()
            
            # Use constant-time comparison to prevent timing attacks
            return hmac.compare_digest(expected_signature, signature)
            
        except Exception as e:
            logger.error("Signature validation error", extra={'error': str(e)})
            return False
    
    def invalidate_cache(self, tenant_id: str = None) -> None:
        """
        Invalidate secret cache
        
        Args:
            tenant_id: Specific tenant to invalidate, or None for all
        """
        self.secret_cache.invalidate(tenant_id)
        
        if tenant_id:
            logger.info("Cache invalidated for tenant", extra={'tenant_id': tenant_id})
        else:
            logger.info("All cache entries invalidated")
    
    def get_performance_stats(self) -> Dict[str, Any]:
        """Get performance statistics"""
        cache_stats = self.secret_cache.get_stats()
        cache_hit_rate = (
            self.cache_hits / (self.cache_hits + self.cache_misses)
            if (self.cache_hits + self.cache_misses) > 0 else 0
        )
        
        return {
            'validation_count': self.validation_count,
            'cache_hits': self.cache_hits,
            'cache_misses': self.cache_misses,
            'cache_hit_rate': cache_hit_rate,
            'cached_entries': cache_stats['entries'],
            'cache_memory_bytes': cache_stats['memory_usage_bytes']
        }
    
    def reset_stats(self) -> None:
        """Reset performance statistics"""
        self.validation_count = 0
        self.cache_hits = 0
        self.cache_misses = 0


# Global validator instance for Lambda container reuse
_global_validator = None


def get_validator(secret_prefix: str = None, 
                 timestamp_tolerance: int = 300,
                 cache_ttl: int = 300) -> HMACValidator:
    """
    Get global HMAC validator instance for container reuse
    
    Args:
        secret_prefix: Secret prefix (uses env var if not provided)
        timestamp_tolerance: Timestamp tolerance in seconds
        cache_ttl: Cache TTL in seconds
        
    Returns:
        Configured HMACValidator instance
    """
    global _global_validator
    
    if _global_validator is None:
        import os
        prefix = secret_prefix or os.environ.get('SECRET_PREFIX', 'formbridge')
        _global_validator = HMACValidator(
            secret_prefix=prefix,
            timestamp_tolerance_seconds=timestamp_tolerance,
            cache_ttl_seconds=cache_ttl
        )
        
        logger.info("HMAC validator initialized", extra={
            'secret_prefix': prefix,
            'timestamp_tolerance': timestamp_tolerance,
            'cache_ttl': cache_ttl
        })
    
    return _global_validator