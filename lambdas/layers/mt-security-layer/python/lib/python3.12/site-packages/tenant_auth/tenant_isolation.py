"""
Tenant Isolation Utilities - ARM64 Optimized
Provides utilities for enforcing multi-tenant data isolation in Lambda functions
"""

import re
import hashlib
from typing import Dict, Any, Optional, List, Union
from dataclasses import dataclass
from enum import Enum
import boto3
from aws_lambda_powertools import Logger

logger = Logger(child=True, service="tenant-isolation")


class ResourceType(Enum):
    """Supported resource types for tenant isolation"""
    SUBMISSION = "SUB"
    FORM = "FORM"
    DESTINATION = "DEST" 
    WEBHOOK = "HOOK"
    ANALYTICS = "ANALYTICS"
    AUDIT = "AUDIT"
    RATE_LIMIT = "RATE"
    SECRET = "SECRET"


@dataclass
class TenantContext:
    """Tenant context for request processing"""
    tenant_id: str
    domain: Optional[str] = None
    validated_at: Optional[str] = None
    permissions: List[str] = None
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.permissions is None:
            self.permissions = []
        if self.metadata is None:
            self.metadata = {}


class TenantValidationError(Exception):
    """Raised when tenant validation fails"""
    pass


class TenantIsolation:
    """
    Multi-tenant isolation utilities for ARM64 Lambda functions
    Ensures data isolation and prevents cross-tenant access
    """
    
    # Tenant ID validation patterns
    TENANT_ID_PATTERN = re.compile(r'^t_[a-zA-Z0-9_-]{3,50}$')
    RESERVED_PREFIXES = ['system_', 'admin_', 'internal_', 'test_']
    
    @classmethod
    def validate_tenant_id(cls, tenant_id: str, strict: bool = True) -> bool:
        """
        Validate tenant ID format and security
        
        Args:
            tenant_id: Tenant identifier to validate
            strict: Whether to enforce strict validation rules
            
        Returns:
            True if valid tenant ID
        """
        if not tenant_id or not isinstance(tenant_id, str):
            return False
        
        # Basic format validation
        if not cls.TENANT_ID_PATTERN.match(tenant_id):
            return False
        
        if strict:
            # Check for reserved prefixes
            tenant_slug = tenant_id[2:]  # Remove 't_' prefix
            if any(tenant_slug.startswith(prefix) for prefix in cls.RESERVED_PREFIXES):
                logger.warning("Attempted use of reserved tenant prefix", extra={
                    'tenant_id': tenant_id
                })
                return False
            
            # Additional security checks
            if '..' in tenant_id or '/' in tenant_id or '\\' in tenant_id:
                return False
        
        return True
    
    @classmethod
    def extract_tenant_from_context(cls, event: Dict[str, Any]) -> TenantContext:
        """
        Extract tenant context from Lambda event
        
        Args:
            event: Lambda event containing authorizer context
            
        Returns:
            TenantContext with extracted information
            
        Raises:
            TenantValidationError: If tenant context is invalid
        """
        try:
            # Try API Gateway authorizer context
            authorizer = (event.get('requestContext', {})
                         .get('authorizer', {}))
            
            # Support both lambda authorizer and custom authorizer formats
            if 'lambda' in authorizer:
                auth_context = authorizer['lambda']
            else:
                auth_context = authorizer
            
            tenant_id = auth_context.get('tenant_id')
            
            if not tenant_id:
                # Fallback: check headers directly
                headers = event.get('headers', {})
                tenant_id = (headers.get('X-Tenant-ID') or 
                           headers.get('x-tenant-id'))
            
            if not tenant_id:
                raise TenantValidationError("Tenant ID not found in request context")
            
            if not cls.validate_tenant_id(tenant_id):
                raise TenantValidationError(f"Invalid tenant ID format: {tenant_id}")
            
            # Build context
            context = TenantContext(
                tenant_id=tenant_id,
                domain=auth_context.get('domain'),
                validated_at=auth_context.get('validated_at'),
                metadata=auth_context.copy()
            )
            
            logger.debug("Tenant context extracted", extra={
                'tenant_id': tenant_id,
                'has_domain': bool(context.domain)
            })
            
            return context
            
        except Exception as e:
            logger.error("Failed to extract tenant context", extra={'error': str(e)})
            raise TenantValidationError(f"Invalid tenant context: {str(e)}")
    
    @classmethod
    def build_partition_key(cls, tenant_id: str, resource_type: ResourceType, 
                          resource_id: str = None) -> str:
        """
        Build DynamoDB partition key with tenant isolation
        
        Args:
            tenant_id: Tenant identifier
            resource_type: Type of resource
            resource_id: Optional specific resource ID
            
        Returns:
            Tenant-isolated partition key
        """
        if not cls.validate_tenant_id(tenant_id):
            raise TenantValidationError(f"Invalid tenant ID: {tenant_id}")
        
        if resource_id:
            return f"TENANT#{tenant_id}#{resource_type.value}#{resource_id}"
        else:
            return f"TENANT#{tenant_id}#{resource_type.value}"
    
    @classmethod
    def build_sort_key(cls, resource_type: ResourceType, 
                      resource_id: str, suffix: str = None) -> str:
        """
        Build DynamoDB sort key for resource
        
        Args:
            resource_type: Type of resource
            resource_id: Resource identifier
            suffix: Optional suffix for the sort key
            
        Returns:
            Sort key for DynamoDB
        """
        if suffix:
            return f"{resource_type.value}#{resource_id}#{suffix}"
        else:
            return f"{resource_type.value}#{resource_id}"
    
    @classmethod
    def validate_resource_access(cls, tenant_context: TenantContext,
                               resource_tenant_id: str) -> bool:
        """
        Validate that tenant can access specific resource
        
        Args:
            tenant_context: Current tenant context
            resource_tenant_id: Tenant ID associated with resource
            
        Returns:
            True if access is allowed
        """
        if tenant_context.tenant_id != resource_tenant_id:
            logger.warning("Cross-tenant access attempt", extra={
                'requesting_tenant': tenant_context.tenant_id,
                'resource_tenant': resource_tenant_id
            })
            return False
        
        return True
    
    @classmethod
    def sanitize_tenant_data(cls, data: Dict[str, Any], 
                           allowed_fields: List[str] = None) -> Dict[str, Any]:
        """
        Sanitize tenant data for safe processing
        
        Args:
            data: Raw tenant data
            allowed_fields: List of allowed field names
            
        Returns:
            Sanitized data dictionary
        """
        sanitized = {}
        
        # Default allowed fields if not specified
        if allowed_fields is None:
            allowed_fields = [
                'tenant_id', 'domain', 'form_id', 'submission_id',
                'payload', 'metadata', 'submitted_at', 'processed_at',
                'destinations', 'status', 'retry_count'
            ]
        
        for key, value in data.items():
            if key in allowed_fields:
                # Additional sanitization for specific fields
                if key == 'tenant_id' and not cls.validate_tenant_id(str(value)):
                    logger.warning("Invalid tenant_id in data", extra={'tenant_id': value})
                    continue
                
                sanitized[key] = value
        
        return sanitized
    
    @classmethod
    def generate_tenant_hash(cls, tenant_id: str, data: str) -> str:
        """
        Generate secure hash for tenant-specific data
        
        Args:
            tenant_id: Tenant identifier
            data: Data to hash
            
        Returns:
            SHA-256 hash string
        """
        if not cls.validate_tenant_id(tenant_id):
            raise TenantValidationError(f"Invalid tenant ID: {tenant_id}")
        
        # Combine tenant ID with data for isolation
        combined = f"{tenant_id}:{data}"
        return hashlib.sha256(combined.encode('utf-8')).hexdigest()
    
    @classmethod
    def build_iam_session_tags(cls, tenant_context: TenantContext) -> Dict[str, str]:
        """
        Build IAM session tags for cross-service tenant isolation
        
        Args:
            tenant_context: Tenant context information
            
        Returns:
            Dictionary of session tags
        """
        tags = {
            'TenantId': tenant_context.tenant_id,
            'ServiceType': 'FormBridge',
            'Environment': 'production'  # This could be parameterized
        }
        
        if tenant_context.domain:
            # Clean domain for tag value (remove special characters)
            clean_domain = re.sub(r'[^a-zA-Z0-9.-]', '', tenant_context.domain)
            if clean_domain:
                tags['Domain'] = clean_domain[:64]  # AWS tag value limit
        
        return tags
    
    @classmethod
    def build_cloudwatch_dimensions(cls, tenant_context: TenantContext,
                                  additional_dims: Dict[str, str] = None) -> List[Dict[str, str]]:
        """
        Build CloudWatch metric dimensions with tenant isolation
        
        Args:
            tenant_context: Tenant context
            additional_dims: Additional dimensions to include
            
        Returns:
            List of CloudWatch dimensions
        """
        dimensions = [
            {'Name': 'TenantId', 'Value': tenant_context.tenant_id}
        ]
        
        if tenant_context.domain:
            dimensions.append({'Name': 'Domain', 'Value': tenant_context.domain})
        
        if additional_dims:
            for name, value in additional_dims.items():
                dimensions.append({'Name': name, 'Value': str(value)})
        
        return dimensions
    
    @classmethod
    def validate_cross_service_request(cls, tenant_context: TenantContext,
                                     target_service: str, 
                                     resource_arn: str = None) -> bool:
        """
        Validate cross-service request for tenant isolation
        
        Args:
            tenant_context: Current tenant context
            target_service: Target AWS service name
            resource_arn: Optional resource ARN to validate
            
        Returns:
            True if request is allowed
        """
        # Basic validation
        if not cls.validate_tenant_id(tenant_context.tenant_id):
            return False
        
        # Service-specific validation could be added here
        allowed_services = ['s3', 'dynamodb', 'events', 'stepfunctions', 'sns', 'sqs']
        if target_service.lower() not in allowed_services:
            logger.warning("Attempted access to restricted service", extra={
                'tenant_id': tenant_context.tenant_id,
                'service': target_service
            })
            return False
        
        # ARN validation if provided
        if resource_arn:
            # Ensure ARN doesn't contain cross-tenant identifiers
            if tenant_context.tenant_id not in resource_arn:
                logger.warning("Cross-tenant ARN access attempt", extra={
                    'tenant_id': tenant_context.tenant_id,
                    'resource_arn': resource_arn
                })
                return False
        
        return True
    
    @classmethod
    def mask_sensitive_data(cls, data: Dict[str, Any], 
                          sensitive_fields: List[str] = None) -> Dict[str, Any]:
        """
        Mask sensitive fields in tenant data for logging
        
        Args:
            data: Data dictionary to mask
            sensitive_fields: List of sensitive field names
            
        Returns:
            Data with sensitive fields masked
        """
        if sensitive_fields is None:
            sensitive_fields = [
                'api_key', 'secret', 'password', 'token', 'webhook_secret',
                'email', 'phone', 'ssn', 'credit_card'
            ]
        
        masked = data.copy()
        
        def mask_value(value: Any) -> str:
            """Mask a single value"""
            str_val = str(value)
            if len(str_val) <= 4:
                return '****'
            return str_val[:2] + '*' * (len(str_val) - 4) + str_val[-2:]
        
        def mask_recursive(obj: Union[Dict, List, Any]) -> Any:
            """Recursively mask sensitive data"""
            if isinstance(obj, dict):
                return {
                    key: mask_value(value) if key.lower() in [f.lower() for f in sensitive_fields]
                    else mask_recursive(value)
                    for key, value in obj.items()
                }
            elif isinstance(obj, list):
                return [mask_recursive(item) for item in obj]
            else:
                return obj
        
        return mask_recursive(masked)


# Utility functions for common operations
def get_tenant_partition_key(tenant_id: str, resource_type: str, resource_id: str = None) -> str:
    """Convenience function for building partition keys"""
    try:
        rt = ResourceType(resource_type.upper())
        return TenantIsolation.build_partition_key(tenant_id, rt, resource_id)
    except ValueError:
        raise TenantValidationError(f"Invalid resource type: {resource_type}")


def validate_tenant_request(event: Dict[str, Any]) -> TenantContext:
    """Convenience function for validating tenant requests"""
    return TenantIsolation.extract_tenant_from_context(event)